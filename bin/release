#! /bin/zsh -euf

source /usr/share/build-system/functions.sh
possibly_trace

export INSTALL_IMMEDIATELY=y

function usage()
{
cat <<EOF
usage: ${0##*/} [+-r Distro] [+-r arch] [+-t tag} [-p dput-target]* [-v version ] [-s]

by defaut:
Distro .... previous from debian/changelog or ??
Tag ... distro/version
dput-target ... taken from MBS_TARGETS env variable

-b  ... ignore Git branch
-i  ...
-s  ... build the tarball/source package too.
EOF
}

# options:
USER_DISTRIBUTION=""
DISTRIBUTION=""

### Dput
# same what I use in zlogin for MBS_TARGETS!
typeset -T DPUT_TARGETS dput_targets :
dput_targets=()

typeset -a GBP_OPTIONS
GBP_OPTIONS=()
typeset -a DCH_OPTIONS
DCH_OPTIONS=()

FORCE=n
# ARCH


step=major
build_source=no
INSTALL_IMMEDIATELY="n"
while getopts :a:bfr:T:p:iIv:ous OPT; do
    case $OPT in
	a)
	    ARCH="$OPTARG";;
	b)
	    DCH_OPTIONS+=("--ignore-branch")
	    GBP_OPTIONS+=("--git-ignore-branch")
	    ;;
	f)
	    FORCE=y
	    ;;
	p)
	    dput_targets+=($OPTARG)
	    ;;

	r|+r)
	    USER_DISTRIBUTION="$OPTARG"
	    ;;
	T|+T)
	    # git-tag
	    "$OPTARG"
	    ;;
	s)
	    # still  dpkg-buildpackage will call dpkg-source --before-build
	    # which does not do harm, though.
	    build_source=yes
	    ;;
	##  which is?  install the package?
	i)
	    GBP_OPTIONS+=("-i")
	    ;;
	I)
	    INSTALL_IMMEDIATELY="y"
	    ;;
	+I)
	    INSTALL_IMMEDIATELY="n"
	    ;;
	o) # non-interactive/offline
	    DCH_OPTIONS+=("--spawn-editor=snapshot")
	    ;;
	v)
	    USER_VERSION=$OPTARG
	    ;;
	u)
	    GBP_OPTIONS+=("-us"  "-uc")
	    ;;
	*)
	    echo "Unknown option: ${OPTARG-}" >&2
	    usage
	    exit 2
    esac
done
shift $(( OPTIND - 1 ))
OPTIND=1


if [ $build_source != yes ]; then
    GBP_OPTIONS+=(--git-no-create-orig -b)

    # for more architectures:
    # could be -B
    # then I need to build also -A build.
fi

# we always sign.

if [ "$DISTRIBUTION" = "" ]; then
    DISTRIBUTION=${MBS_DISTRO:-release}
fi


# fallback on env-var value:
if [ "$dput_targets" = "" -a -n "${MBS_TARGETS-}" ];
then
    # fixme: since it comes from a generic shell, divide it as such:
    #dput_targets=${=MBS_TARGETS}
    DPUT_TARGETS=${MBS_TARGETS}
fi



# I want to be able to repeat the run.
# So, to skip the changelog and/or  git tag!

# So, changelog if needed.
# git tag if ....needed.
set +e
get_current_tag
# this sets DISTRIBUTION,VERSION & GIT_OFFSET

found_any_tag=$?
set -e

if [ $found_any_tag != 0 ]
then
    cecho red "not past Git tag. Taking hint from the debian/changelog"
    # extract the distro from changelog!
    ls -l debian/changelog
    load_distr_version_from_changelog;
    # DISTRIBUTION & VERSION
    # fixme: If not even there:
    # default version 0.1, distro your current.
fi


# Note: maybe a comitted debian/changelog has a higher
# version n. which was not released with a tag.

function get_new_version()
{
    increase_version $step
    git_version=$VERSION
#fixme:  wtf ^^^^ why?

# git_distro=$DISTRIBUTION
# This should be from
    load_distr_version_from_changelog
    if dpkg --compare-versions $VERSION lt $git_version;
    then

    # increase_version $step
	VERSION=$git_version
    # so the changelog contains a higher
    # version. git-dch would notice it.
    #
    # So, increase more.
    fi

    echo $DISTRIBUTION $VERSION
}




# That obviously implies the Git-Tag, then, on the new commit.
function generate_commit_changelog()
{
    # fixme: this needs the git-last-tag:

    if [ -n "${USER_VERSION:-}" ]
    then
	echo "overriding the version, as requested" >&2
	VERSION=${USER_VERSION}
    else
# fixme: here we need to increase (& hence parse) the VERSION:
	get_new_version;

	#echo "Starting a new version $VERSION."
	#echo "Could have been explicitely specified with the -v option.">&2
	# no need to echo... the user will see it?
    fi

    set -x

    # todo: if modified, reset it. Saving a copy.
    # that copy will be then removed, at the end.
    # This, because snap creates sections, which
    # we don't want here.
    if git status --porcelain debian/changelog| grep '^ M' > /dev/null;
    then
	mv debian/changelog debian/changelog.snap
	git checkout debian/changelog
    fi
    git-dch $DCH_OPTIONS --release --auto --new-version="$VERSION" --distribution $DISTRIBUTION
    rm -f debian/changelog.snap
    set +x
# "--debian-tag=$DISTRIBUTION/%(version)s"

    if git status --porcelain debian/changelog| grep '^ M' > /dev/null;
    then
	git add debian/changelog;
	# get the version and "release $VERSION"
	git commit -m release
    fi
}


# if debian/changelog is up-to-date, skip this:?
# broken...
# if git status --porcelain debian/changelog

# if no debian/changelog or not in Git ->

# if status OR not updated!
if git status --porcelain debian/changelog | grep '^ M' > /dev/null
then
    cecho yellow "debian/changelog is dirty, so let's review it"
    generate_commit_changelog
elif ! git diff HEAD~1 --name-status debian/changelog | grep '^M' > /dev/null
then
    cecho yellow "debian/changelog is NOT up-to-date"
    generate_commit_changelog
elif [ $FORCE = "y" ] ;
then
    generate_commit_changelog
fi



# at this point I have the last commit, but maybe not a tag.
# If a stop here, and rerun, I would like to resume.

# fixme: maybe the tag is there already?
# if NO tag at all:
# fatal: No names found, cannot describe anything.

NEED_TAG="n"
if [ "${GIT_OFFSET:-}" != "" ]
then
    NEED_TAG="y"
    # don't use the version!
fi





# *now* the default value:
# : ${GIT_TAG:=$DISTRIBUTION/$VERSION}

# fixme: this only after `generate_commit_changelog' ... 
load_distr_version_from_changelog
# if different &
: ${NEWGIT_TAG:=$DISTRIBUTION/$VERSION}
NEWGIT_TAG=${NEWGIT_TAG/:/%}

cecho green "git tag is $NEWGIT_TAG"


typeset -a MGB_OPTIONS
MGB_OPTIONS=()
## fixme: 1/ grep  2/ the tag might have ":" converted to %.
if git tag -l "$NEWGIT_TAG"|grep "." > /dev/null
then
    cecho red "the tag $NEWGIT_TAG already exists! not re-creating it now"
else
    MGB_OPTIONS+=(--git-tag "--git-debian-tag=$DISTRIBUTION/%(version)s")
fi


echo exporting DPUT_TARGETS $DPUT_TARGETS
export DPUT_TARGETS

# -sa dpkg-genchanges: force inclusion of original sources (in the changes file)
git-buildpackage \
    --git-ignore-new \
    --git-cleaner=/bin/true \
    --git-prebuild=pre-build-hook -sa \
    --git-posttag=post-tag-hook \
    --git-postbuild=install-dput-snapshot \
    --git-builder="debuild -eMAKEFLAGS -nc" \
    $MGB_OPTIONS $GBP_OPTIONS





#### Source package:

# I'd need $BINARY_BUILD_OPTIONS


# -S is handed over.... git-buildpackage -> debuild -> dpkg-buildpackage.
if false;
then

# again  debian/control   Could be done Once
# again ./auto  Yes
    mygit-buildpackage $GBP_OPTIONS -S

# notice the asymetry: in `snap' we invoke dput on GBP_CHANGES_FILE.
# Here we rely on the debian/changelog to confirm it.
    for target in $DPUT_TARGETS;
    do
	if ! debrelease -S --debs-dir=$BUILD_AREA --dput $target; then
	    (echo "Failed to upload to $target"; echo )>&2
	fi
    done
fi



# todo:
# --git-builder /usr/bin/git-pbuilder
