#! /bin/zsh -euf

source /usr/share/build-system/functions.sh
eval $(possibly_trace)
check_getopt

check_start_gnupg

# Support for 2 different versions of gbp:
gbp_version=$(gbp buildpackage --version|cut -d ' '  -f 2)
GITSHA=""


function usage()
{
    cat <<EOF
usage: ${0##*/} [+-r Distro] [+-a arch] [-m] [-p dput-target]* [-v version ] [-s] [-o]

by defaut:
Distro .... previous from debian/changelog or ??
Tag ... distro/version
dput-target ... taken from MBS_TARGETS env variable

-h --help
-b --ignore  ... ignore Git branch
-f --force ... regenerate & commit even if apparently debian/changelog ...
-i --install ...
-m --minor  ... increase the version only by minor step.
-o --auto  ... don't open the Editor -- Changelog is unverified.    DANGEROUS.
-s --source  ... build the tarball/source package too.

--dput | -p [target] ... add named tput target.
--distr | -r [distro] ... package for that
--tag  [name]  default  {distro}/

-u         don't sign
EOF
}

# defaults for options:
USER_DISTRIBUTION=""
DISTRIBUTION=""
step=minor
build_source=no
FORCE=n
# ARCH


# this is for the (pre/post) hooks
POSTBUILD_INSTALL_OPTIONS="-I"

### Dput
# same what I use in zlogin for MBS_TARGETS!
typeset -T DPUT_TARGETS dput_targets :
dput_targets=()

typeset -a GBP_OPTIONS
GBP_OPTIONS=()
typeset -a DCH_OPTIONS
DCH_OPTIONS=()


cmd_options=$(getopt --name $0 --shell bash \
    --longoptions help,arch,dput,ignore,install,noinstall,pbuilder,tag,version:,nocheck \
    --longoptions force,source,distro:minor,major \
    --options ha:bfr:T:p:iIv:ousmM \
    -- "$@" ) || { usage && exit 1 }
eval set -- "$cmd_options"

while (( $# > 0 )) do

    case $1 in
	--help | -h)
	    usage
	    exit 0
	    ;;
	--arch | -a)
	    shift
	    ARCH="$1"
	    ;;
	--ignore | -b)
	    DCH_OPTIONS+=("--ignore-branch")
	    GBP_OPTIONS+=("--git-ignore-branch")
	    ;;
	--force | -f)
	    FORCE=y
	    ;;
	--dput | -p)
	    shift
	    dput_targets+=($1)
	    ;;

	--distro | -r)
	    shift
	    USER_DISTRIBUTION="$1"
	    GBP_OPTIONS+=("--git-dist=$USER_DISTRIBUTION")
	    ;;
	--tag | -T )
	    shift
	    git_tag=$1
	    ;;
	--source | -s)
	    # still  dpkg-buildpackage will call dpkg-source --before-build
	    # which does not do harm, though.
	    build_source=yes
	    ;;
	##  which is?  install the package?
	--install | -i)
	    # fixme:
	    GBP_OPTIONS+=("-i")
	    ;;
	--install | -i)
	    POSTBUILD_INSTALL_OPTIONS="-i"
	    ;;
	--upgrade | -I)
	    POSTBUILD_INSTALL_OPTIONS="-I"
	    ;;
	--noinstall | +n)
	    POSTBUILD_INSTALL_OPTIONS="-n"
	    ;;

	--auto | -o)
	    # non-interactive/offline
	    DCH_OPTIONS+=("--spawn-editor=snapshot")
	    ;;
	--minor | -m)
	    step=minor
	    ;;
	--major | -M)
	    step=major
	    ;;
	--version | -v)
	    shift
	    USER_VERSION=$1
	    ;;
	-u)
	    # don't sign??
	    GBP_OPTIONS+=("-us"  "-uc")
	    ;;
	--nocheck )
	    DEB_BUILD_OPTIONS+=nocheck
	    export DEB_BUILD_OPTIONS
	    ;;
    esac
    shift
done


# No source package -> optimize
if [ $build_source != yes ]; then
    GBP_OPTIONS+=(--git-no-create-orig -b)
fi

#todo: I could build arch-dependent & independent separately.
# -A build.
# for more architectures: -B builds.



## Check all data is ready/consistent. (Before invoking manual interaction).
# fallback on env-var value:
if [ "$dput_targets" = "" ]; then
    if [ -z "${MBS_TARGETS-}" ];
    then
	cecho red "No targets, only local then"
	exit 1
    else
	# fixme: since it comes from a generic shell, divide it as such:
	#dput_targets=${=MBS_TARGETS}
	DPUT_TARGETS=${MBS_TARGETS}
    fi
fi





## Prepare for the debian/changelog entry:

if [ "$DISTRIBUTION" = "" ]; then
    # todo:
    # when archi  ALL -> release
    # otherwise   lsb_release --short --codename
    DISTRIBUTION=${MBS_DISTRO:-release}
fi

# I want to be able to repeat the run.
# So, update the changelog and git tag only if needed.

## get the current version string.
set +e

# this sets DISTRIBUTION,VERSION & GIT_OFFSET
get_current_tag
found_any_tag=$?
set -e

if [ $found_any_tag != 0 ]
then
    cecho red "not past Git tag. Taking hint from the debian/changelog"
    # extract the distro from changelog!
    load_distr_version_from_changelog;
    # DISTRIBUTION & VERSION

    # todo: further fallback:
    # default version 0.1, distro your current.
fi


# Note: maybe a comitted debian/changelog has a higher
# version n. which was not released with a tag.

# Increase the VERSION, and compara with the one in Changelog.
# Make sure it's bigger than that.
function get_new_version()
{
    increase_version $step
    local git_version=$VERSION
    # git_distro=$DISTRIBUTION

    # This should be from
    load_distr_version_from_changelog
    if dpkg --compare-versions $VERSION lt $git_version;
    then
	# increase_version $step
	VERSION=$git_version
	# so the changelog contains a higher
	# version. git-dch would notice it.
	#
	# So, increase more.
    fi

    echo $DISTRIBUTION $VERSION
}


function reset_changelog()
{
    local FILE=debian/changelog
    # todo: if modified, reset it. Saving a copy.
    # that copy will be then removed, at the end.
    # This, because snap creates sections, which
    # we don't want here.
    if git status --porcelain $FILE| grep '^[M ]M' > /dev/null;
    then
	mv $FILE $FILE.pre-release
	git checkout $FILE
    fi
}

# That obviously implies the Git-Tag, then, on the new commit.
# input: USER_VERSION, USER_DISTRIBUTION, DCH_OPTIONS
# modifies/output: VERSION, DISTRIBUTION,
function generate_commit_changelog()
{
    if [ -n "${USER_VERSION:-}" ]
    then
	echo "overriding the version, as requested" >&2
	VERSION=${USER_VERSION}
    else
	# fixme: here we need to increase (& hence parse) the VERSION:
	get_new_version
	#echo "Starting a new version $VERSION."
	#echo "Could have been explicitely specified with the -v option.">&2
	# no need to echo... the user will see it?
    fi

    [[ -n $USER_DISTRIBUTION ]] && DISTRIBUTION=$USER_DISTRIBUTION

    set -x
    reset_changelog

    if dpkg --compare-versions $gbp_version gt 0.6; then
	# old did not support it.
	if [ -n "$DISTRIBUTION" ]; then
	    DCH_OPTIONS+=(--distribution $DISTRIBUTION)
	fi
    fi

    gbp dch $DCH_OPTIONS --release --auto --new-version="$VERSION"

    # Do the commit:

    # fixme: part of reset_changelog !
    rm -f debian/changelog.pre-release
    set +x
    if git status --porcelain debian/changelog| grep '^[M ]M' > /dev/null;
    then
	git add debian/changelog;
	# todo: "release $VERSION"
	git commit -m "release"
	GITSHA=$(git rev-list  --max-count=1 HEAD)
    # else what to do?
    fi
}



# todo:
# if no debian/changelog or not in Git ->
#  --create

# if status OR not updated!
if changelog_needs_new_section "release"
then
    generate_commit_changelog
fi

# generate_commit_changelog -> get_new_version
#                                 -> load_distr_version_from_changelog

# input: $found_any_tag, GIT_OFFSET (from git-describe(1) )
# side-effects:
#   sets TAGOPTIONS
#   adds to GBP_OPTIONS
function decide_git_tag()
{

    # Design considerations:
    # At this point I have the last commit, but maybe not a tag.
    # If I stop here, and rerun, I would like to resume.
    # fixme: But maybe the tag is there already?

    # if NO tag at all:
    # fatal: No names found, cannot describe anything.

    # global TAGOPTIONS
    local NEED_TAG="n"
    if [ $found_any_tag = 0 -a  "${GIT_OFFSET:-}" = "" ]
    then
	TAGOPTIONS=()
	cecho red "will not create git tag! HEAD already tagged"
    else
	NEED_TAG="y"
	# don't use the version!
	TAGOPTIONS=(--git-posttag=post-tag-hook)
    fi

    if [ $NEED_TAG = "n" ]; then
       return
    fi

    # *now* the default value:
    # : ${GIT_TAG:=$DISTRIBUTION/$VERSION}

    # fixme: this only after `generate_commit_changelog' ...
    # DISTRIBUTION, VERSION
    load_distr_version_from_changelog
    # if different &
    local NEWGIT_TAG
    : ${NEWGIT_TAG:=$DISTRIBUTION/$VERSION}
    NEWGIT_TAG=${NEWGIT_TAG/:/%}

    cecho green "Will git tag after successful build: $NEWGIT_TAG"


    ## fixme: 1/ grep  2/ the tag might have ":" converted to %.
    if git tag -l "$NEWGIT_TAG"|grep "." > /dev/null
    then
	cecho red "the tag $NEWGIT_TAG already exists! not re-creating it now"
    else
	GBP_OPTIONS+=(--git-tag "--git-debian-tag=$DISTRIBUTION/%(version)s")
    fi
}

decide_git_tag


if dpkg --compare-versions $gbp_version 'gt' 0.6; then
    PREVERSION_HOOK_NAME=--git-postexport
else
    PREVERSION_HOOK_NAME=--git-prebuild
fi


echo exporting DPUT_TARGETS $DPUT_TARGETS
export DPUT_TARGETS

export GITSHA

BUILDER="debuild -eMAKEFLAGS -eGITSHA -nc"
# BUILDER="pflask-debuild -eMAKEFLAGS -nc"
# -sa dpkg-genchanges: force inclusion of original sources (in the changes file)

set -x
gbp buildpackage \
    --git-ignore-new \
    --git-cleaner=/bin/true \
    $PREVERSION_HOOK_NAME=pre-build-hook \
    --git-postbuild="dput-install -r $POSTBUILD_INSTALL_OPTIONS" -b \
    $TAGOPTIONS \
    --git-builder=$BUILDER \
    $GBP_OPTIONS

# todo:
# --git-builder /usr/bin/git-pbuilder
